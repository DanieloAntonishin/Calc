﻿VCS - Version Control System
Система забезпечення "точок відновлення", до яких завжди можна
повернути проєкт
Git			   Github, Gitlab
Mercurial	   Bitbucket

- зберігаються лише зміни (додавання, видалення, зміна)
  (коміти - commit - архів змін)
- НЕ прийнято включати до VCS
  = залежності (пакети, які можут бути завантажені після
      встановлення проєкту)
  = результати компіляції (EXE, DLL і т.п., у т.ч. проміжні - OBJ, cash)
  = файли баз даних (??)
  = тимчасові файли, у т.ч. файли-конфіги IDE ("студії") - .vs, .idea
  == всі виключення прописуються у спеціальному файлі .gitignore
      файл має бути орієнтованим на саме ту систему, з якою іде робота
       ("студія", мова програмування, тощо) - універсального файлу не існує
       https://github.com/github/gitignore - колекція типових файлів
     файл .gitignore може бути у кожній папці і діяти лише на неї
      (включно з під-каталогами)

Початок роботи з VCS, як правило, відбувається за схемами:
 1. Існує проєкт на локальному ПК, його треба перенести на Git
 2. Існує проєкт на Git, його треба скопіювати на локальний ПК


1:
 - переконатись, що на ПК встановлені засоби git (https://git-scm.com/)
 - або засобами "студії", або через консоль (командний рядок)
   = git init     це створить у каталозі приховану папку .git
 - вносимо зміни у код (працюємо над проєктом)
 - реєструємо ці зміни
   = git add ./               додати поточну папку (всі файли)
   = git commit -m "The message"    створюємо коміт (локально)
   = git push --all           відправити у віддалений репозиторій
 - конфлікти виникають коли зміни зроблені одночасно і при 
    внесенні змін з одного ПК не враховуються зміни, зроблені
    з іншого

Д.З. Повторити вправу зі створенням конфлікту - 
 внести зміни через веб-інтерфейс та (параллельно) у студії
 (або консолі/bash). Прикріпити скриншот графу
 ** створити граф як на лого git (https://git-scm.com/)

2: Існує проєкт на Git, його треба скопіювати на локальний ПК
 (для сумісної роботи)
 - власник проєкту має включити учасника до проєкту (надати доступ)
 - учасник проєкту має підтвердити участь у проєкті (погодитись)
 - клонування проєкту на локальний ПК

--------------------------------------------------------------
Тестування
Є різні види тестування, акцент на модульному тестуванні
 Тести (тестові методи) - тематичне спрямування
 Групи тестів (тестові класи) - засіб групування тестів
 Надгрупи тестів - іншні рівні ієрархії
Основу тестів складають твердження (Asserts), які перевіряються
 та визнаються підтвердженими або спростованими.
 Якщо всі твердження підтверджені, то тест вважається пройденим
 Якщо хоча б одне спростоване - тест вважается проваленим (Fail).
 Як правило, провал одного з тестів НЕ зупиняє процес тестування
  і інші тести все одно перевіряются
У деяких системах повідомлення виводяться для кожного твердження
 (для кожного виклику Assert). У системі MSTest "одиницею" 
 повідомлень є тестовий метод (у якому може бути багато Assert)
Розділення тестів на логічні групи (методи) дозволяє більш 
 якісно шукати помилки у роботі модуля.

-------------------------------------------------------------------
Рефакторинг
 - прием в программировании, нацеленный на улучшение кода, но, не
изменяющий его алгоритмическую часть.
!! Рефакторинг не добавляет функциональность, не исправляет ошибки,
   а только улучшает реализацию заданных алгоритмов. Изменения в
   алгоритмах вносить прием "Оптимизация"

Рефакторинг в ХР играет особую роль. В силу того что код пишется 
 быстро (экстремально быстро), он содержит много того, что нужно
 будет улучшить.
 Цикл разработки в ХР идет по схеме 
  [ТЗ] - тесты - [код] - рефакторинг
 Если на конец цикла нет нового ТЗ, то цикл продолжается без него

Игнорирование рефакторинга приводит к появлению "Технического долга"
 (Technical Debt) - отложенных изменений в коде, которые его улучшают.
 Код с большим "долгом" также называют "код с запахом" и классифицируют
 недостатки кода как "запахи"

Рефакторинг содержит набор правил по поиску недостатков
 и рекомендаций по их исправлению. Поэтому возможны автоматизированные
 инструменты рефакторинга. Однако, их полность автоматическое использование
 не приветствуется, т.к. ряд критериев является интеллектуальным.

В противоложность коду "с долгами" говорят о "чистом" коде. Чистый код
 первоначально оценивают по следующим критериям:
 - Понятен для других программистов
 - Проходит все тесты
 - Логично сгруппированный
    = Нет дублирований (связанных дублирований, которые нужно менять синхронно)
    = Минимализм - нет лишних "абстракций"
    = Максимализм - нет слишком больших объединений

Рефакторинг - это комплекс действий по улучшению чистоты кода


Методы (приемы) рефакторинга
             (=Группа -Набор *Метод(ы))
= Объекты (Классы) : группа приемов, нацеленная на изменения в схеме (способе)
    организации, группировке объектов, их классов и интерфейсов
 - Объединение (Collapse)
  * Классов
  * Интерфейсов
 - Разъединение (Декомпозиция)
  * Отделение подклассов
  * Отделение суперклассов
  * Разделение интерфейсов
 - Реорганизация (перераспределение)
  * Перемещение вверх
  * Перемещение вниз
  * Изменение связей и их типа (наследование / композиция / агрегация)

= Сигнатуры : приемы, направленные на изменения в способах вызова функций,
    методов, передачи им параметров и возврате результатов
 - Названия методов и видимость (public/private/protected)
  * Скрытие метода
  * Открытие метода
  * Переименование метода (параметров)
 - Изменения в параметрах
  * Добавление параметров
  * Удаление параметров
  * Группировка параметров (порядок или инкапсуляция - помещение в объект)
     fun(x,y,z) ---> fun(Point3D)
 - Изменения в возврате
  * Преобразование в фабрику (возврат объектов)
  * Исключение <--> возврат ошибки
    void writeLog(f) throws Exception      vs       bool writeLog(f)
    { if(...) throw new Exc }                       { if(...) return false }
                        main() { ... writeLog(f); ... }

= Конструкции управления : приемы, направленные на изменения в условиях 
    и циклах
 - Изменение конструкций ветвления 
  * Объединение условий/case 
  * Разъединение условий (if(){ if() })
  * Инверсия условий ( !x && !y && !z  <-->  !(x || y || z) )
  * Замена if <--> switch
  * Замена условных блоков полиморфизмом
   if(){do1()}else{do2()}    --->  if(){new Obj1().do()} else{new Obj2().do()}
 - Изменение цикловых конструкций
  * Линеаризация <---> цикл (for(3){doSmth();}  <---> doSmth();doSmth();doSmth();)
  * Условные <---> Счетчики

= Данные
 - Изменение типа
  * Reference <--> Value
  * Primitive --> Object
  * Arrays <--> Object
 - Группирование
  * Инкапсуляция
  * Разделение
 - Изменение связности
  * Замена "магических чисел" на константы  ( int x *= 1.5;  -> int x *= SPEED_X;)
  * Замена констант на методы ( const int PI = 3; --> int Pi() {ret 3}  )
  * Удаление связей "один-к-одному"

= Код
 - Изменения в группировании (без изменений тела)
  * Инкапсуляция (методы -> объект)
  * Разделение
  * Отказ от метода (Inline-методы)
  * Перемещение по иерархии
  * Перенос в прототип (или в методы расширения)
 - Реорганизация (изменения тела)
  * Разделение на несколько методов
  * Соединение в один
VCS - Version Control System
Система забезпечення "точок відновлення", до яких завжди можна
повернути проєкт
Git			   Github, Gitlab
Mercurial	   Bitbucket

- зберігаються лише зміни (додавання, видалення, зміна)
  (коміти - commit - архів змін)
- НЕ прийнято включати до VCS
  = залежності (пакети, які можут бути завантажені після
      встановлення проєкту)
  = результати компіляції (EXE, DLL і т.п., у т.ч. проміжні - OBJ, cash)
  = файли баз даних (??)
  = тимчасові файли, у т.ч. файли-конфіги IDE ("студії") - .vs, .idea
  == всі виключення прописуються у спеціальному файлі .gitignore
      файл має бути орієнтованим на саме ту систему, з якою іде робота
       ("студія", мова програмування, тощо) - універсального файлу не існує
       https://github.com/github/gitignore - колекція типових файлів
     файл .gitignore може бути у кожній папці і діяти лише на неї
      (включно з під-каталогами)

Початок роботи з VCS, як правило, відбувається за схемами:
 1. Існує проєкт на локальному ПК, його треба перенести на Git
 2. Існує проєкт на Git, його треба скопіювати на локальний ПК


1:
 - переконатись, що на ПК встановлені засоби git (https://git-scm.com/)
 - або засобами "студії", або через консоль (командний рядок)
   = git init     це створить у каталозі приховану папку .git
 - вносимо зміни у код (працюємо над проєктом)
 - реєструємо ці зміни
   = git add ./               додати поточну папку (всі файли)
   = git commit -m "The message"    створюємо коміт (локально)
   = git push --all           відправити у віддалений репозиторій
 - конфлікти виникають коли зміни зроблені одночасно і при 
    внесенні змін з одного ПК не враховуються зміни, зроблені
    з іншого

Д.З. Повторити вправу зі створенням конфлікту - 
 внести зміни через веб-інтерфейс та (параллельно) у студії
 (або консолі/bash). Прикріпити скриншот графу
 ** створити граф як на лого git (https://git-scm.com/)

2: Існує проєкт на Git, його треба скопіювати на локальний ПК
 (для сумісної роботи)
 - власник проєкту має включити учасника до проєкту (надати доступ)
 - учасник проєкту має підтвердити участь у проєкті (погодитись)
 - клонування проєкту на локальний ПК

--------------------------------------------------------------
Тестування
Є різні види тестування, акцент на модульному тестуванні
 Тести (тестові методи) - тематичне спрямування
 Групи тестів (тестові класи) - засіб групування тестів
 Надгрупи тестів - іншні рівні ієрархії
Основу тестів складають твердження (Asserts), які перевіряються
 та визнаються підтвердженими або спростованими.
 Якщо всі твердження підтверджені, то тест вважається пройденим
 Якщо хоча б одне спростоване - тест вважается проваленим (Fail).
 Як правило, провал одного з тестів НЕ зупиняє процес тестування
  і інші тести все одно перевіряются
У деяких системах повідомлення виводяться для кожного твердження
 (для кожного виклику Assert). У системі MSTest "одиницею" 
 повідомлень є тестовий метод (у якому може бути багато Assert)
Розділення тестів на логічні групи (методи) дозволяє більш 
 якісно шукати помилки у роботі модуля.

-------------------------------------------------------------------
Рефакторинг
 - прием в программировании, нацеленный на улучшение кода, но, не
изменяющий его алгоритмическую часть.
!! Рефакторинг не добавляет функциональность, не исправляет ошибки,
   а только улучшает реализацию заданных алгоритмов. Изменения в
   алгоритмах вносить прием "Оптимизация"

Рефакторинг в ХР играет особую роль. В силу того что код пишется 
 быстро (экстремально быстро), он содержит много того, что нужно
 будет улучшить.
 Цикл разработки в ХР идет по схеме 
  [ТЗ] - тесты - [код] - рефакторинг
 Если на конец цикла нет нового ТЗ, то цикл продолжается без него

Игнорирование рефакторинга приводит к появлению "Технического долга"
 (Technical Debt) - отложенных изменений в коде, которые его улучшают.
 Код с большим "долгом" также называют "код с запахом" и классифицируют
 недостатки кода как "запахи"

Рефакторинг содержит набор правил по поиску недостатков
 и рекомендаций по их исправлению. Поэтому возможны автоматизированные
 инструменты рефакторинга. Однако, их полность автоматическое использование
 не приветствуется, т.к. ряд критериев является интеллектуальным.

В противоложность коду "с долгами" говорят о "чистом" коде. Чистый код
 первоначально оценивают по следующим критериям:
 - Понятен для других программистов
 - Проходит все тесты
 - Логично сгруппированный
    = Нет дублирований (связанных дублирований, которые нужно менять синхронно)
    = Минимализм - нет лишних "абстракций"
    = Максимализм - нет слишком больших объединений

Рефакторинг - это комплекс действий по улучшению чистоты кода


Методы (приемы) рефакторинга
             (=Группа -Набор *Метод(ы))
= Объекты (Классы) : группа приемов, нацеленная на изменения в схеме (способе)
    организации, группировке объектов, их классов и интерфейсов
 - Объединение (Collapse)
  * Классов
  * Интерфейсов
 - Разъединение (Декомпозиция)
  * Отделение подклассов
  * Отделение суперклассов
  * Разделение интерфейсов
 - Реорганизация (перераспределение)
  * Перемещение вверх
  * Перемещение вниз
  * Изменение связей и их типа (наследование / композиция / агрегация)

= Сигнатуры : приемы, направленные на изменения в способах вызова функций,
    методов, передачи им параметров и возврате результатов
 - Названия методов и видимость (public/private/protected)
  * Скрытие метода
  * Открытие метода
  * Переименование метода (параметров)
 - Изменения в параметрах
  * Добавление параметров
  * Удаление параметров
  * Группировка параметров (порядок или инкапсуляция - помещение в объект)
     fun(x,y,z) ---> fun(Point3D)
 - Изменения в возврате
  * Преобразование в фабрику (возврат объектов)
  * Исключение <--> возврат ошибки
    void writeLog(f) throws Exception      vs       bool writeLog(f)
    { if(...) throw new Exc }                       { if(...) return false }
                        main() { ... writeLog(f); ... }

= Конструкции управления : приемы, направленные на изменения в условиях 
    и циклах
 - Изменение конструкций ветвления 
  * Объединение условий/case 
  * Разъединение условий (if(){ if() })
  * Инверсия условий ( !x && !y && !z  <-->  !(x || y || z) )
  * Замена if <--> switch
  * Замена условных блоков полиморфизмом
   if(){do1()}else{do2()}    --->  if(){new Obj1().do()} else{new Obj2().do()}
 - Изменение цикловых конструкций
  * Линеаризация <---> цикл (for(3){doSmth();}  <---> doSmth();doSmth();doSmth();)
  * Условные <---> Счетчики

= Данные
 - Изменение типа
  * Reference <--> Value
  * Primitive --> Object
  * Arrays <--> Object
 - Группирование
  * Инкапсуляция
  * Разделение
 - Изменение связности
  * Замена "магических чисел" на константы  ( int x *= 1.5;  -> int x *= SPEED_X;)
  * Замена констант на методы ( const int PI = 3; --> int Pi() {ret 3}  )
  * Удаление связей "один-к-одному"

= Код
 - Изменения в группировании (без изменений тела)
  * Инкапсуляция (методы -> объект)
  * Разделение
  * Отказ от метода (Inline-методы)
  * Перемещение по иерархии
  * Перенос в прототип (или в методы расширения)
 - Реорганизация (изменения тела)
  * Разделение на несколько методов
  * Соединение в один
  
----------------------------------------------------------------------
Рефакторинг. Практика
1. Методы Add
 Ситуация: несколько методов Add (перегрузки) явно реализуют алгоритм 
   сложения чисел (делегируют оператору +)
 Проблема: если понадобится изменить алгоритм сложения, то придется
   менять код во всех методах (дублировать изменения)
 Решение: реализовать алгоритм в одном методе, остальные перегрузки
   вызывают этот метод.
 Add{x+y} Add{a+b}  --->  Add{x+y}, Add(a,b){Add(x,y)}  

2. Фабричность vs Перегрузки
 Фабричность - создание объекта по разнообразным характеристикам
  MakeObject(object data)   /   MakeObject(String name)
 Перегрузки - наличие множества методов под каждую из характеристик
  MakeObject(int data), MakeObject(float data), MakeObject(String data)

 Фабричность более элластична, позволяет легко расширить множество
 поддерживаемых типов. В то же время, контроль правильности - runtime.
 Повышенная роль документации и ее актуальности. Алгоритм централизован,
 изменения - в одном месте.

 Перегрузки контроллируют на этапе компиляции, ошибки видно сразу.
 Добавление новых типов требует описания новых методов, если организация
 не качественная, то алгоритмы распределены, изменения придется повторять
 в нескольких методах.
-----------------------------------------------------------------------
 "Магические" значения - константы - ресурсы
 "Магические" (Hardcoded) значения - значения (числа, строки, массивы),
   которые появляются в коде.
 В любом случае от таких значений нужно избавляться. Рекомендация (строгая):
  в коде должен быть только код, все значения (возможно, кроме 0) должны
  быть перемещены в "секцию данных".
 1. В коде просматриваются строки с сообщениями об исключениях, их нужно
  переносить.
  Строки-константы ("Empty string not allowed")
  Строки с плейсхолдерами -- строки, часть которых формируется в коде
   ("Invalid char {digit}") --> "Invalid char %c"
        const String EMPTY_STRING_EXCEPTION = "Empty string not allowed";
        const String INVALID_CHAR_EXCEPTION = "Invalid char %c";
        const String INVALID_TYPE_EXCEPTION = "obj%d: type unsupported";
 2. Создаем объект-поставщик ресурсов, это позволит сгруппировать
  ресурсы разных классов - не искать их раздельно, а иметь единый ресурс
    public class Resources
    {
        public static String GetEmptyStringMessage(){...}
        ...
    }
   Идея ресурсов позволяет:
    - использовать гарантированно одинаковые ресурсы в разных классах приложения
    - менять значения ресурсов, также одновременно для всех классов
    - использовать в тестах ссылки на ресурсы
    - внедрять локализацию/глобализацию - значения ресурсов для разных культур
  Культура (culture) - указание локализации в виде хх-ХХ 
   где хх - код языка, ХХ - код страны
   код языка - ISO 639-1
   код страны - ISO 3166-1
   пример: uk-UA, ru-UA
---------------------------------------------------------------------------
Рефакторинг. Инверсия управления.

объект1 -- объект2
объект1 - интерфейс - объект2

Наш пример - ресурсы. Все объекты программы обращаются к ресурсам
Связь жесткая - если переносить класс в другой проект, придется также
переносить ресурсы.

Решение - 
 а) отказываемся от static, переходим к объекту - получаем возможность
     динамической замены одного объекта на другой
 б) заменяем прямое обращение к статическим ресурсам на обращение к 
     объекту, ссылка на который является свойством (полем) объекта - 
     получаем "место внедрения" (точку инъекции) зависимости
 в) находим точку, через которую проходят все программные инструкции
     (Main), в этой точке создаем объекты ресурсов и внедряем 
     зависимости в точки инъекции